# Console style
$Host.UI.RawUI.WindowTitle = "User & Computer Query"
#$Host.UI.RawUI.BackgroundColor = "Black"
$Host.UI.RawUI.ForegroundColor = "Gray"

# Output style
$HeadingStyle = @{ ForegroundColor = "DarkYellow" }
$ContentStyle = @{ ForegroundColor = "Cyan"; NoNewLine = $true }
$RedStyle = @{ ForegroundColor = "Red" }

$CompanyTenantID = "91f09566-a850-4fae-bbe1-29ad3804a2f6"
# Intune_A service ID
$IntuneServicePlanID = "c1ec4a95-1f05-45b3-a911-aa3fa01094f5"
# Scopes necessary to run all cmdlets in the script
$Scopes = @(
    "Application.Read.All"
    "AuditLog.Read.All"
    "Device.ReadWrite.All"
    "DeviceManagementManagedDevices.ReadWrite.All"
    "DeviceManagementServiceConfig.ReadWrite.All"
    "Directory.AccessAsUser.All"
    "Directory.Read.All"
    "Group.Read.All"
    "Group.ReadWrite.All"
    "GroupMember.ReadWrite.All"
    "openid"
    "Organization.Read.All"
    "Policy.Read.All"
    "profile"
    "RoleManagement.Read.Directory"
    "User.Read"
    "User.ReadWrite.All"
    "email"
)

<# As of 2023-08-19 Get-MgUser is not capable of returning all properties using an asterix,
an explicit declaration of desired properties is necessary #>
$UserProps = @(
    "Id"
    #"DisplayName"
    "GivenName"
    "Surname"
    "Mail"
    "UserPrincipalName"
    "OtherMails"
    "OnPremisesSamAccountName"
    "JobTitle"
    "BusinessPhones"
    "MobilePhone"
    "Country"
    "City"
    "StreetAddress"
    "PostalCode"
    "CompanyName"
    "Department"
    "LastPasswordChangeDateTime"
    "PasswordPolicies"
    "AccountEnabled"
    "CreatedDateTime"
    "OnPremisesLastSyncDateTime"
    "OnPremisesDistinguishedName"
)

<# The following hash table has been generated by downloading a .csv file from 
https://learn.microsoft.com/en-us/azure/active-directory/enterprise-users/licensing-service-plan-reference
and running below code:

$Subscriptions = Get-MgSubscribedSku -All
$SkuIDs = $Subscriptions.SkuId
$Content = Import-Csv -Path "C:\Users\loberauskis\OneDrive - DXC Production\Desktop\products.csv"
foreach($SkuID in $SkuIDs) {
	$Name = $Content | Where-Object { $_.GUID -eq "$($SkuID)" } | Select-Object -First 1 -ExpandProperty Product_Display_Name
	Write-Host "`"$SkuID`" = `"$Name`""
}

Some SkuIDs were still nameless and were added manually by getting SkuPartNumber values from the license object
#>
$FriendlyLicenseNames = @{
    "c5928f49-12ba-48f7-ada3-0d743a3601d5" = "Visio Online Plan 2"
    "1f2f344a-700d-42c9-9427-5cea1d5d7ba6" = "Microsoft Stream"
    "6ec92958-3cc1-49db-95bd-bc6b3798df71" = "Dynamics 365 Sales Premium Viral Trial"
    "5b22585d-1b71-4c6b-b6ec-160b1a9c2323" = "Dynamics 365 Sales Enterprise Attach to Qualifying Dynamics 365 Base Offer"
    "87bbbc60-4754-4998-8c88-227dca264858" = "Power Apps and Logic Flows"
    "4a51bf65-409c-4a91-b845-1121b571cc9d" = "Power Automate per user plan"
    "29fcd665-d8d1-4f34-8eed-3811e3fca7b3" = "Dynamics 365 Field Service Viral Trial"
    "c9a0aa67-747d-4dbf-a9ae-844575460a44" = "Dynamics_365_Intelligent_Order_Management_vTrial"
    "f8a1db68-be16-40ed-86d5-cb42ce701560" = "Power BI Pro"
    "8f0c5670-4e56-4892-b06d-91c085d7004f" = "App Connect IW"
    "61e6bd70-fbdb-4deb-82ea-912842f39431" = "Dynamics 365 Customer Service Insights Trial"
    "b126b073-72db-4a9d-87a4-b17afe41d4ab" = "Microsoft Defender for Endpoint P2_XPLAT"
    "571fe374-4138-4f36-800b-e80bd67c300c" = "POWERFLOW_P1"
    "7ac9fe77-66b7-4e5e-9e46-10eed1cff547" = "Dynamics 365 Team Members"
    "6470687e-a428-4b7a-bef2-8a291ad947c9" = "Windows Store for Business"
    "d2dea78b-507c-4e56-b400-39447f4738f8" = "AI Builder Capacity add-on"
    "a4bfb28e-becc-41b0-a454-ac680dc258d3" = "Dynamics 365 Enterprise Edition - Additional Portal (Qualified Offer)"
    "f30db892-07e9-47e9-837c-80727f46fd3d" = "Microsoft Power Automate Free"
    "26124093-3d78-432b-b5dc-48bf992543d5" = "Microsoft 365 E5 Security"
    "e485d696-4c87-4aac-bf4a-91b2fb6f0fa7" = "Dynamics 365 Operations - Sandbox Tier 2:Standard Acceptance Testing"
    "e43b5b99-8dfb-405f-9987-dc307f34bcbd" = "Microsoft Teams Phone Standard"
    "3a349c99-ffec-43d2-a2e8-6b97fcb71103" = "Viva_Goals_User_led"
    "80b2d799-d2ba-4d2a-8842-fb0d0f3a4b82" = "Exchange Online Kiosk"
    "beb6439c-caad-48d3-bf46-0c82871e12be" = "Project Plan 1"
    "606b54a9-78d8-4298-ad8b-df6ef4481c80" = "Power Virtual Agents Viral Trial"
    "7b26f5ab-a763-4c00-a1ac-f6c4b5506945" = "Power BI Premium P1"
    "bc946dac-7877-4271-b2f7-99d2db13cd2c" = "Dynamics 365 Customer Voice Trial"
    "dcb1a3ae-b33f-4487-846a-a640262fadf4" = "Microsoft Power Apps Plan 2 Trial"
    "f2e48cb3-9da0-42cd-8464-4a54ce198ad0" = "Dynamics 365 for Supply Chain Management"
    "338148b6-1b11-4102-afb9-f92b6cdc0f8d" = "Dynamics 365 P1 Tria for Information Workers"
    "85430fb9-02e8-48be-9d7e-328beb41fa29" = "Dynamics 365 for Marketing Attach"
    "e0dfc8b9-9531-4ec8-94b4-9fec23b05fc8" = "Microsoft_Teams_Exploratory_Dept"
    "57f3babd-73ce-40de-bcb2-dadbfbfff9f7" = "Power Apps Portals login capacity add-on Tier 2 (10 unit min)"
    "749742bf-0d37-4158-a120-33567104deeb" = "Dynamics 365 for Customer Service Enterprise Edition"
    "e06abcc2-7ec5-4a79-b08b-d9c282376f72" = "Dynamics 365 - Additional Non-Production Instance (Qualified Offer)"
    "7d7af6c2-0be6-46df-84d1-c181b0272909" = "Dynamics 365 for Customer Service Chat"
    "84a661c4-e949-4bd2-a560-ed7766fcaf2b" = "Azure Active Directory Premium P2"
    "6070a4c8-34c6-4937-8dfb-39bbc6397a60" = "Microsoft Teams Rooms Standard"
    "c55410cb-36d5-47f0-9b9f-5bcca0f31c1b" = "DYN365_CS_OC_MESSAGING_VOICE"
    "b56e7ccc-d5c7-421f-a23b-5c18bdbad7c0" = "Dynamics 365 Talent: Onboard"
    "a403ebcc-fae0-4ca2-8c8c-7a907fd6c235" = "Microsoft Fabric (Free)"
    "111046dd-295b-4d6d-9724-d52ac90bd1f2" = "Microsoft Defender for Endpoint"
    "ddfae3e3-fcb2-4174-8ebd-3023cb213c8b" = "Microsoft Power Apps Plan 2 (Qualified Offer)"
    "c2ac2ee4-9bb1-47e4-8541-d689c7e83371" = "Microsoft 365 E3 - Unattended License"
    "d721f2e4-099b-4105-b40e-872e46cad402" = "DYN365_FINANCE_ATTACH"
    "3bbd44ed-8a70-4c07-9088-6232ddbd5ddd" = "Dynamics 365 Operations - Device"
    "06ebc4ee-1bb5-47dd-8120-11324bc54e06" = "Microsoft 365 E5"
    "b75074f1-4c54-41bf-970f-c9ac871567f5" = "Dyn365_Operations_Activity"
    "3f9f06f5-3c31-472c-985f-62d9c10ec167" = "Power Pages vTrial for Makers"
    "b30411f5-fea1-4a59-9ad9-3db7c7ead579" = "Power Apps per user plan"
    "efccb6f7-5641-4e0e-bd10-b4976e1bf68e" = "Enterprise Mobility + Security E3"
    "fcecd1f9-a91e-488d-a918-a96cdb6ce2b0" = "Microsoft Dynamics AX7 User Trial"
    "0c266dff-15dd-4b49-8397-2bb16070ed52" = "Microsoft 365 Audio Conferencing"
    "2ced8a00-3ed1-4295-ab7c-57170ff28e58" = "POWERAPPS_PER_USER_BD_ONLY"
    "50f60901-3181-4b75-8a2c-4c8e4c1d5a72" = "Microsoft 365 F1"
    "eb18b715-ea9d-4290-9994-2ebf4b5042d2" = "Dynamics 365 for Customer Service Enterprise Attach to Qualifying Dynamics 365 Base Offer A"
    "05e9a617-0261-4cee-bb44-138d3ef5d965" = "Microsoft 365 E3"
    "53818b1b-4a27-454b-8896-0dba576410e6" = "Project Plan 3"
    "eda1941c-3c4f-4995-b5eb-e85a42175ab9" = "Power Automate per user with attended RPA plan"
    "66b55226-6b4f-492c-910c-a3b7a3c9d993" = "Microsoft 365 F3"
    "e612d426-6bc3-4181-9658-91aa906b0ac0" = "Common Data Service Database Capacity"
    "6a4a1628-9b9a-424d-bed5-4118f0ede3fd" = "Dynamics 365 Business Central for IWs"
    "b4d7b828-e8dc-4518-91f9-e123ae48440d" = "Power Apps per app plan (1 app or portal)"
    "328dc228-00bc-48c6-8b09-1fbc8bc3435d" = "Dynamics 365 - Additional Database Storage (Qualified Offer)"
    "4cde982a-ede4-4409-9ae6-b003453c8ea6" = "Microsoft Teams Rooms Pro"
    "ba929637-f158-4dee-927c-eb7cdefcd955" = "Microsoft Viva Goals"
    "8c4ce438-32a7-4ac5-91a6-e22ae08d9c8b" = "Rights Management Adhoc"
    "1c27243e-fb4d-42b1-ae8c-fe25c9616588" = "Microsoft Teams Audio Conferencing with dial-out to USA/CAN"
    "448b063f-9cc6-42fc-a0e6-40e08724a395" = "Common Data Service Log Capacity"
    "5b631642-bd26-49fe-bd20-1daaa972ef80" = "Microsoft Power Apps for Developer"
    "4ef96642-f096-40de-a3e9-d83fb2f90211" = "Microsoft Defender for Office 365 (Plan 1)"
    "18181a46-0d4e-45cd-891e-60aabd171b4e" = "Office 365 E1"
}


Function New-Line {
    Write-Host ""
}


Function Connect-AgentToMgGraph {
    [CmdletBinding()]
    param (
        [string]$TenantID
    )
    try {
        Connect-MgGraph -TenantId $TenantID -Scopes $Scopes -ErrorAction Stop | Out-Null
    }
    # Handle the possible closure of the authentication window
    catch {
        Write-Host "Connection failed" @RedStyle
        Write-Host $_.Exception.Message @RedStyle
        Pause
        Break
    }
}


Function Get-AgentName {
    [CmdletBinding()]
    param ()
    $Context = Get-MgContext
    $UserPrincipalName = $Context.Account
    $AgentObject = Get-MgUser -Filter "UserPrincipalName eq '$UserPrincipalName'" -ErrorAction SilentlyContinue
    Return $AgentObject.GivenName
}


Function Write-Greeting {
    [CmdletBinding()]
    param ()
    $Name = Get-AgentName
    Clear-Host
    Write-Host "Greetings " $Name
}


Function Get-AgentInput {
    [CmdletBinding()]
    param ()
    Clear-Host
    $UserInput = (Read-Host -Prompt "Search for").Trim()
    Clear-Host
    if([string]::IsNullOrWhiteSpace($UserInput)) {
        Write-Host "No input detected"
        Return
    }
    Return $UserInput
}


Function Search-UserByEmailAddress {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$EmailAddress
    )
        # First try to find the user by e-mail address
        $User = Get-MgUser -Filter "Mail eq '$EmailAddress'" -Property $UserProps -ErrorAction SilentlyContinue
        <# If not found, try by UPN. Sometimes they are different and using parameter "UserId" does not find the user
        Using "Filter" does not throw any errors if a user is not found, therefore error handling is not necessary #>
        if($null -eq $User) {
            $User =Get-MgUser -Filter "UserPrincipalName eq '$EmailAddress'" -Property $UserProps -ErrorAction SilentlyContinue
        }
        if($null -eq $User) {
            Write-Host "Could not find user by e-mail `"$($EmailAddress)`", please try again"
            Return
        }
    Return $User
}


Function Search-UserByADID {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$ADID
    )
    # Parameters mandatory for advanced search which uses "Search" parameter
    $UserSearchParams = @{ ConsistencyLevel = "eventual"; CountVariable = "CountVar" }
    $SearchString = "`"OnPremisesSamAccountName:$ADID`""
    $User = Get-MgUser @UserSearchParams -Search $SearchString -Property $UserProps -ErrorAction SilentlyContinue |
        # Narrow down the search to only return results with exact match
        Where-Object { $_.OnPremisesSamAccountName -eq $ADID}
    # Searching with "Search" does not throw an exception if an object is not found, therefore need to verify
    if($null -eq $User) {
        Write-Host "Could not find user by userID `"$($ADID)`", please try again"
        Return
    }
    Return $User
}


Function Get-UserByAgentInput {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$AgentInput
    )
    if($AgentInput -like "*@*") {
        $User = Search-UserByEmailAddress -EmailAddress $AgentInput -ErrorAction SilentlyContinue
    } else {
        $User = Search-UserByADID -ADID $AgentInput -ErrorAction SilentlyContinue
    }
    Return $User
}


Function Convert-OnPremisesDistinguishedNameToHumanReadable {
    [CmdletBinding()]
    param (
        $RawString
    )
    if(![string]::IsNullOrWhiteSpace($RawString)) {
        # Let's say we have a raw string "CN=Name MiddleName-Surname\, IT,OU=Employees,OU=Company,OU=Accounts,DC=PDK,DC=pnad,DC=pninfrasrv,DC=net"
        # 1 step: separate domain and the rest. Part 1 is the domain
        $Part2, $Part1 = $RawString -split "DC="
        <# After this piece
        Part1 = 
        PDK,
        pnad,
        pninfrasrv,
        net
        Part2 = CN=Name MiddleName-Surname\, IT,OU=Employees,OU=Company,OU=Accounts,
        #>
        # 2 step: replace commas with dots in the domain
        $Part1 = $Part1 -join "" -replace ",", "."
        # Part1 = PDK.pnad.pninfrasrv.net
        # 3 step: eliminate unnecessary strings from the path, separate parts with slashes, take care of spaces if there are such
        $Part2 = $Part2 -replace "CN=|OU=", "" -replace ",", "/" -replace "\\/", ","
        # Part2 = Name MiddleName-Surname, IT/Employees/Company/Accounts/
        # 4 step: split the path based on slashes but keep the slashes intact
        $Elements = $Part2 -split "(?<=/)"
        <#
        Elements = 
        Name MiddleName-Surname, IT/
        Employees/
        Company/
        Accounts/

        #>
        # 5 step: create a separate string for writing the path in reverse order
        $NewStr = ""
        for($i = $Elements.Length - 2; $i -ge 0; $i --) { $NewStr += $Elements[$i] }
        # NewStr = Accounts/Company/Employees/Name MiddleName-Surname, IT/
        $NewStr = "/" + $NewStr.TrimEnd("/")
        # NewStr = /Accounts/Company/Employees/Name MiddleName-Surname, IT
        $FQOUPath = $Part1 + "$NewStr"
        # FQOUPath = PDK.pnad.pninfrasrv.net/Accounts/Company/Employees/Name MiddleName-Surname, IT

        # Return fully qualified organizational unit path
        Return $FQOUPath
    } else {
        Return ""
    }
}


Function Get-UsersDevices {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $UserID
    )
    $DeviceNames = @()
    $DeviceIDs = Get-MgUserOwnedDevice -UserId $UserID -ErrorAction SilentlyContinue | Select-Object -ExpandProperty Id
    foreach($DeviceID in $DeviceIDs) {
        $DeviceNames += (Get-MgDevice -DeviceId $DeviceID | Select-Object -ExpandProperty DisplayName)
    }
    Return $DeviceNames
}


# The function looks for a user-friendly name in the hash table and uses it if found, otherwise a raw name is used
Function Convert-LicenseNamesToFriendly {
    [CmdletBinding()]
    param (
        $LicenseObject
    )
    $LicenseNames = @()
    if($null -ne $LicenseObject) {
        $LicenseIDs = $LicenseObject.SkuId
        foreach($LicenseID in $LicenseIDs) {
            try {
                $LicenseName = $FriendlyLicenseNames["$LicenseID"]
                $LicenseNames += $LicenseName
            } catch {
                $LicenseNames += $LicenseObject.SkuPartNumber
            }
        }
    }
    Return $LicenseNames
}


Function Get-IntunePlanStatus {
    [CmdletBinding()]
    param (
        $LicenseObject
    )
    $IntunePlanStatus = ""
    $LicensesContainingActiveIntunePlan = @()
    if($null -ne $LicenseObject) {
        foreach($License in $LicenseObject) {
            foreach($ServicePlan in $License.ServicePlans) {
                if(($ServicePlan.ServicePlanId -eq $IntuneServicePlanID) -and ($ServicePlan.ProvisioningStatus -ne "Disabled")) {
                    $LicensesContainingActiveIntunePlan += $(Convert-LicenseNamesToFriendly -LicenseObject $License)
                }
            }
        }
        if($LicensesContainingActiveIntunePlan.Count -gt 0) {
            $IntunePlanStatus = "On `($($LicensesContainingActiveIntunePlan -join ", ")`)"
        } else {
            $IntunePlanStatus = "Off"
        }
    }
    Return $IntunePlanStatus
}


# This function takes a MgUser object and returns an ordered hash table containing information about the user
Function Get-UserInfo {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [ValidateNotNull()]
        $User
    )
    $LicenseDetail = Get-MgUserLicenseDetail -UserId $User.Id -ErrorAction SilentlyContinue
    $LicenseNames = (Convert-LicenseNamesToFriendly -LicenseObject $LicenseDetail) -join ", "
    $IntunePlanStatus = Get-IntunePlanStatus -LicenseObject $LicenseDetail
    $Devices = (Get-UsersDevices -UserID $User.Id) -join ", "
    $UserAllInfo = [ordered]@{

        # Contact info
        ContactInfo = [ordered]@{
            Heading = "CONTACT"
            Name = $User.GivenName
            Surname = $User.Surname
            "E-mail" = $User.Mail
            "Other E-mails" = $User.OtherMails
            ADID = $User.OnPremisesSamAccountName
            Position = $User.JobTitle
            "Work Phone" = $User.BusinessPhones
            "Mobile" = $User.MobilePhone
            Address = ($User.StreetAddress, $User.City, $User.Country, $User.PostalCode -join " ")
            Company = $User.CompanyName
            Department = $User.Department
        }

        # Password
        PasswordInfo = [ordered]@{
            Heading = "PASSWORD"
            "Last Set" = $User.LastPasswordChangeDateTime
            Expires = $(if($User.PasswordPolicies -eq "DisablePasswordExpiration") { "No" } else { "Yes" })
        }

        # Login
        LoginInfo = [ordered]@{
            Heading = "LOGIN"
            # Last sign in date/time is only available using the user GUID
            "Last Logon" = (Get-MgUser -UserId $User.Id -Property SignInActivity).SignInActivity.LastSignInDateTime
        }

        # Account
        AccountInfo = [ordered]@{
            Heading = "ACCOUNT"
            Enabled = $User.AccountEnabled
            Created = $User.CreatedDateTime
            "Last Synced" = $User.OnPremisesLastSyncDateTime
            "UPN" = $User.UserPrincipalName
            "OU Path" = (Convert-OnPremisesDistinguishedNameToHumanReadable -RawString $User.OnPremisesDistinguishedName)
        }

        # Other (licenses, devices, intune plan)
        OtherInfo = [ordered]@{
            Heading = "OTHER"
            Licenses = $LicenseNames
            "Intune Plan" = ($IntunePlanStatus -join ", ")
            Devices = $Devices
        }
    }
    Return $UserAllInfo
}


Function Search-DeviceByName {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$DeviceName
    )
    <# Since not all devices are managed, some devices would not be found using the below command. 
    "Get-MgDevice" is capable to find all devices, including non-managed ones. For this reason,
    although "Get-MgDeviceManagementManagedDevice" contains more information and is more convenient
    to use, "Get-MgDevice" is chosen #>
        $Device = Get-MgDevice -Filter "DisplayName eq '$DeviceName'" -ErrorAction SilentlyContinue
        if($null -eq $Device) {
            Write-Host "Could not find the device by name `"$($DeviceName)`", please try again"
            Return
        } elseif ($Device.Count -gt 1) {
            Write-Host "$($Device.Count) devices found, name `"$($DeviceName)`" too generic. Please check in Azure portal"
            Return
        } elseif (!$Device.IsManaged) {
            Write-Host "Device `"$($DeviceName)`" does not exist in Endpoint, found in AzureAD"
        }
    Return $Device
}


Function Get-DeviceInfo {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true, Position = 0)]
        [ValidateNotNull()]
        $Device
    )
    # Device user and group tag are extracted from PhysicalIDs hashtable property of the MgDevice object
    $PhysicalIDs = $Device.PhysicalIds
    # Some devices do not contain any PhysicalIDs properties, therefore need to check in order to avoid calling a method on $null
    if($PhysicalIDs.Count -gt 0) { $UserHWID = $PhysicalIDs | Where-Object { $_ -like "*USER-HWID*" } }
    if($null -ne $UserHWID) { $UserID = $UserHWID.Split(":")[1] }
    $OrderID = $PhysicalIDs | Where-Object { $_ -match ".*\[OrderId\]:.*" }
    # Manufacturer and model are extracted from AdditionalProperties
    $AdditionalProperties = $Device.AdditionalProperties
    # Last sync is only available in managed device objects. Devices which are not in endpoint do not have this information
    if($Device.IsManaged) {
        $ManagedDevice = Get-MgDeviceManagementManagedDevice -Filter "DeviceName eq '$($Device.DisplayName)'" -ErrorAction SilentlyContinue
    }
    $DeviceInfo = [ordered]@{
        GeneralInfo = [ordered]@{
            Heading = "GENERAL"
            Name = $Device.DisplayName
            Compliant = $Device.IsCompliant
            "Group Tag" = $(
                if($null -ne $OrderID) {
                    $OrderID.Split(":")[1] 
                }
            )
            Owner = $(
                if($null -ne $UserID) {
                    (Get-MgUser -UserId $UserID -ErrorAction SilentlyContinue).Mail 
                }
            )
            "Registered" = $Device.RegistrationDateTime
            "Last Sync" = $(
                if($Device.IsManaged) { $ManagedDevice.LastSyncDateTime 
                }
            )
            "Brand, Model" = $($AdditionalProperties.manufacturer, $AdditionalProperties.model)
            "OS" = $Device.OperatingSystem, $Device.OperatingSystemVersion
            "Free Space" = $(
                if($Device.IsManaged) {
                    $('{0:N2}' -f ($ManagedDevice.FreeStorageSpaceInBytes/1Gb) + " Gb") 
                }
            )
        }
    }
    Return $DeviceInfo
}


#This function takes a hash table and displays its contents. It is designed to handle only hash tables that contain other hash tables
Function Show-Info {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $Info
    )
    foreach($Key in $Info.Keys) {
        $Info[$Key].GetEnumerator().foreach({
            if($_.Key -eq "Heading") {
                New-Line
                Write-Host $_.Value @HeadingStyle
            } else {
                Write-Host "$($_.Key): " @ContentStyle;
                if($_.Value -eq $false) {
                    Write-Host $_.Value @RedStyle
                } else {
                    Write-Host $_.Value
                }
                # Option to choose not to display pieces of information where values are empty
                <# if (![string]::IsNullOrWhiteSpace($_.Value)) {
                } #>
            }
        })
    }
    New-Line
    New-Line
}


Function Start-Script {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        $Alternative
    )
    $AgentInput = Get-AgentInput
    switch ($Alternative) {
        "1" {
                try {
                    $User = Get-UserByAgentInput -AgentInput $AgentInput -ErrorAction SilentlyContinue
                    $Info = Get-UserInfo -User $User -ErrorAction SilentlyContinue
                } catch {
                    Return
                }
            }
        "2" {
                try {
                    $Device = Search-DeviceByName -DeviceName $AgentInput -ErrorAction SilentlyContinue
                    $Info = Get-DeviceInfo -Device $Device -ErrorAction Stop
                } catch {
                    Return
                }
            }
    }
    Show-Info -Info $Info
}


Function Start-Program {
    [CmdletBinding()]
    param ()
    do {
        New-Line
        Write-Host "1 - User (Search by e-mail or AD ID)"
        Write-Host "2 - Device (Search by device name)"
        Write-Host "0 - Disconnect and exit"
        New-Line
        $Alternative = Read-Host "Enter option"
        switch ($Alternative) {
            { ($_ -eq "1") -or ($_ -eq "2") } { Clear-Host; Start-Script -Alternative $Alternative; Pause; Clear-Host }
            "0" { Clear-Host; Disconnect-MgGraph; Return }
            Default { Clear-Host; Write-Host "Please pick an option" }
        }
    } until ($Alternative -eq "0")
}


# Connect, greet and run
Connect-AgentToMgGraph -TenantID $CompanyTenantID
Write-Greeting
Start-Program